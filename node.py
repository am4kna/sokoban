from copy import deepcopy
import itertools


class Node:
    def __init__(self, sokobanPuzzle, parent=None, action="", g=1, tab_stat=None):
        self.state = sokobanPuzzle  
        self.parent = parent
        self.action = action  # Action that led to this state
        self.g = g if parent is None else parent.g + g  # Path cost (step cost = 1)
        self.depth = 0 if parent is None else parent.depth + 1
        self.moves = "" if parent is None else parent.moves + action
        self.tab_stat = tab_stat  # Passing static elements as an instance variable

    def getPath(self):
        """Returns a list of states representing the path from the initial state to the current node."""
        path = []
        node = self
        while node is not None:
            path.append(node.state.tab_dyn)
            node = node.parent
        return path[::-1]  # Return the path from initial state to goal

    def getSolution(self):  # Return the solution of the search problem, the solution is stored in a list, each element of the list is a string, the string is the move that leads to the next state, the solution is generated by backtracking from the goal node to the root node, and the moves that lead to the next state are stored in the moves attribute of the class Node, the moves are stored in the order of the moves that lead to the next state, so the solution is generated by reversing the moves attribute of the class Node
        node = self # The current node is the goal node
        solution = [] # The solution is stored in a list
        while node: # Iterate over the nodes in the search tree, the iteration stops when the current node is the root node, the root node is the node that has no parent node, so the iteration stops when the parent node is None
            height = len(node.state.tab_dyn) # The height of the puzzle is the number of rows in the puzzle
            width = len(node.state.tab_dyn[0]) # The width of the puzzle is the number of columns in the puzzle
            state = deepcopy(Node.tab_stat) # Create a copy of the wall, space and obstacle of the puzzle, the copy is used to print the puzzle, the copy is used to avoid changing the wall, space and obstacle of the puzzle
            for i, j in itertools.product(range(height), range(width)): # Iterate over the rows and columns of the puzzle 
                if node.state.tab_dyn[i][j] == 'R': # Check if the current cell is the robot cell or not, 
                    if state[i][j] == ' ': # Check if the current cell is a space cell or not
                        state[i][j] = 'R' # If the current cell is a space cell, then change the current cell to the robot cell, 
                    else: # If the current cell is not a space cell, then the current cell is a box cell
                        state[i][j] = '.' # Change the current cell to the goal cell
                elif node.state.tab_dyn[i][j] == 'B': # Check if the current cell is a box cell or not
                    if state[i][j] == ' ': # Check if the current cell is a space cell or not
                        state[i][j] = 'B' # If the current cell is a space cell, then change the current cell to the box cell
                    else: # If the current cell is not a space cell, then the current cell is a goal cell
                        state[i][j] = '*' # Change the current cell to the goal cell                 
            solution.append(state) # Add the current state to the solution
            node = node.parent # The current node is the parent node of the current node 
        solution = solution[::-1] # Reverse the solution, the solution is generated by backtracking from the goal node to the root node, so the solution is generated by reversing the moves attribute of the class Node, the moves are stored in the order of the moves that lead to the next state, so the solution is generated by reversing the moves attribute of the class Node
        return solution 

    